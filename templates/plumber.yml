spec:
  inputs:
    # Authentication
    # Uses CI_JOB_TOKEN by default (no setup required!)
    # For additional permissions (e.g., cross-project access), set GITLAB_TOKEN as a CI/CD variable
    gitlab_token:
      description: "GitLab API token (CI_JOB_TOKEN works for most use cases)"
      default: $CI_JOB_TOKEN
    
    # Project configuration
    # These can be overridden but default to GitLab CI predefined variables
    project_path:
      description: "Full path of the GitLab project to analyze"
      default: $CI_PROJECT_PATH
    branch:
      description: "Branch to analyze"
      default: $CI_COMMIT_REF_NAME
    server_url:
      description: "GitLab instance URL"
      default: $CI_SERVER_URL
    
    # Control configuration
    # default conf can be found at https://gitlab.com/getplumber/plumber/-/blob/main/.plumber.yaml
    config_file:
      description: "Path to .plumber.yaml config file inside the container. Will use the default if not provided."
      default: "/.plumber.yaml"
    
    # Compliance configuration
    threshold:
      description: "Minimum compliance percentage required to pass (0-100)"
      type: number
      default: 100
    
    # Output configuration
    print_output:
      description: "Print text output to stdout"
      type: boolean
      default: true
    output_file:
      description: "Write JSON results to file (optional, leave empty to skip)"
      default: "plumber-report.json"
    
    # Job configuration
    stage:
      description: "Stage to run the job in"
      default: ".pre"
    image:
      description: "Docker image to use for the job"
      default: "getplumber/plumber:0.1"
    allow_failure:
      description: "Allow the job to fail without failing the pipeline"
      default: false
      type: boolean
    verbose:
      description: "Enable verbose/debug output for troubleshooting"
      default: false
      type: boolean

---

# Plumber Component
# Analyzes GitLab CI/CD pipelines for compliance issues
#
# Prerequisites:
#   1. Set GITLAB_TOKEN as a CI/CD variable in your project settings
#      (Settings > CI/CD > Variables) - use masked/protected for security
#
# Usage in .gitlab-ci.yml:
#   include:
#     - component: gitlab.com/getplumber/plumber/plumber@~latest
#
# With custom inputs:
#   include:
#     - component: gitlab.com/getplumber/plumber/plumber@v0.1.0
#       inputs:
#         threshold: 80
#         output_file: results.json
#         gitlab_token: $MY_CUSTOM_TOKEN_VAR

"plumber":
  stage: $[[ inputs.stage ]]
  image:
    name: $[[ inputs.image ]]
    entrypoint: [""]  # Override ENTRYPOINT to allow shell script execution
  variables:
    # Use intermediate variable to avoid self-reference when default is $GITLAB_TOKEN
    PLUMBER_TOKEN: $[[ inputs.gitlab_token ]]
  script:
    - |
      # Export as GITLAB_TOKEN for the CLI
      export GITLAB_TOKEN="$PLUMBER_TOKEN"
      OUTPUT_FLAG=""
      if [ -n "$[[ inputs.output_file ]]" ]; then
        OUTPUT_FLAG="--output $[[ inputs.output_file ]]"
      fi
      VERBOSE_FLAG=""
      if [ "$[[ inputs.verbose ]]" = "true" ]; then
        VERBOSE_FLAG="--verbose"
      fi
      /plumber analyze \
        --gitlab-url "$[[ inputs.server_url ]]" \
        --project "$[[ inputs.project_path ]]" \
        --branch "$[[ inputs.branch ]]" \
        --config "$[[ inputs.config_file ]]" \
        --threshold "$[[ inputs.threshold ]]" \
        --print="$[[ inputs.print_output ]]" \
        $OUTPUT_FLAG \
        $VERBOSE_FLAG
  artifacts:
    paths:
      - $[[ inputs.output_file ]]
    when: always
    expire_in: 1 week
  allow_failure: $[[ inputs.allow_failure ]]
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG
